/**********************************************************************************************************************
 * \file main.c
 * \copyright Copyright (C) Infineon Technologies AG 2024
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/
/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/

#include "cybsp.h"
#include "cy_pdl.h"
#include "cy_retarget_io.h"


/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
/* The priority for interrupt */
#define GPIO_INTERRUPT_PRIORITY (7u)

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
/* The status of SW1 interrupt */
volatile bool g_isInterrupt_SW1 = false;

/* P-DMA interrupt configuration */
const cy_stc_sysint_t TX_DMA_2D_INT_CFG =
{
    .intrSrc      = ( (NvicMux4_IRQn << CY_SYSINT_INTRSRC_MUXIRQ_SHIFT) | (IRQn_Type)TxDma2D_IRQ ),
    .intrPriority = 6u,
};

const cy_stc_sysint_t BTN_IRQ_CFG =
{
    .intrSrc = ((NvicMux3_IRQn << CY_SYSINT_INTRSRC_MUXIRQ_SHIFT) | CYBSP_USER_BTN_IRQ),
    .intrPriority = GPIO_INTERRUPT_PRIORITY
};

/* Source data to be transferred */
const uint8_t SOURCE_DATA[] =
{
    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F',
    'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',
    'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l',
    'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '!', '@',
};

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
void handle_GPIO_Interrupt_SW1(void);

/**********************************************************************************************************************
 * Function Name: handle_GPIO_Interrupt_SW1
 * Summary:
 *  GPIO interrupt handler for SW1.
 * Parameters:
 *  handlerArg (unused)
 *  event (unused)
 * Return:
 *  none
 **********************************************************************************************************************
 */
void handle_GPIO_Interrupt_SW1(void)
{
    Cy_GPIO_ClearInterrupt(CYBSP_USER_BTN_PORT, CYBSP_USER_BTN_NUM);

    g_isInterrupt_SW1 = true;
}

/**********************************************************************************************************************
 * Function Name: handle_PDMA_Interrupt
 * Summary:
 *  Handles PDMA interrupt.
 * Parameters:
 *  none
 * Return:
 *  none
 **********************************************************************************************************************
 */
static void handle_PDMA_Interrupt(void)
{
    cy_en_dma_intr_cause_t chStatus;

    Cy_DMA_Channel_ClearInterrupt(TxDma2D_HW, TxDma2D_CHANNEL);

    /* Check interrupt cause to capture errors. */
    chStatus = Cy_DMA_Channel_GetStatus(TxDma2D_HW, TxDma2D_CHANNEL);
    if (chStatus == CY_DMA_INTR_CAUSE_COMPLETION)
    {
        Cy_SCB_UART_PutString(UART_HW, "\r\nX-loop done!\r\n\n");
    }
    else
    {
        char buf[16];
        sprintf(buf, "\r\nerror:%d\r\n\n", chStatus);
        Cy_SCB_UART_PutString(UART_HW, buf);

        CY_ASSERT(0);
    }
}

/**********************************************************************************************************************
 * Function Name: main
 * Summary:
 *  This is the main function.
 * Parameters:
 *  none
 * Return:
 *  int
 **********************************************************************************************************************
 */
int main(void)
{

    /* Initialize the device and board peripherals */
    if (cybsp_init() != CY_RSLT_SUCCESS)
    {
        CY_ASSERT(0);
    }

    /* Enable global interrupts */
    __enable_irq();

    /* Initialize the SW1 */
    Cy_GPIO_Pin_Init(CYBSP_USER_BTN_PORT, CYBSP_USER_BTN_NUM, &CYBSP_USER_BTN1_config);

    /* Initialize retarget-io to use the debug UART port */
    Cy_SCB_UART_Init(UART_HW, &UART_config, NULL);
    Cy_SCB_UART_Enable(UART_HW);
    cy_retarget_io_init(UART_HW);

    /* Transmit header to the terminal */
    /* \x1b[2J\x1b[;H - ANSI ESC sequence for clear screen */
    Cy_SCB_UART_PutString(UART_HW, "\x1b[2J\x1b[;H");
    
    Cy_SCB_UART_PutString(UART_HW, "************************************************************\r\n");
    Cy_SCB_UART_PutString(UART_HW, "PDMA 2D Transfer code example\r\n");
    Cy_SCB_UART_PutString(UART_HW, "************************************************************\r\n\n");
    Cy_SCB_UART_PutString(UART_HW, ">> push USER_BTN1 to transfer 4-bytes of X(row) \r\n\n");

    /* Configure GPIO interrupt for SW1 */
    Cy_SysInt_Init(&BTN_IRQ_CFG, &handle_GPIO_Interrupt_SW1);
    NVIC_ClearPendingIRQ((IRQn_Type)BTN_IRQ_CFG.intrSrc);
    NVIC_EnableIRQ((IRQn_Type) NvicMux3_IRQn);

    /* Initialize PDMA */
    if (Cy_DMA_Descriptor_Init(&TxDma2D_Descriptor_0, &TxDma2D_Descriptor_0_config) != CY_DMA_SUCCESS)
    {
        CY_ASSERT(0);
    }
    if (Cy_DMA_Channel_Init(TxDma2D_HW, TxDma2D_CHANNEL, &TxDma2D_channelConfig) != CY_DMA_SUCCESS)
    {
        CY_ASSERT(0);
    }

    /* Set source and destination address for PDMA descriptor */
    Cy_DMA_Descriptor_SetSrcAddress(&TxDma2D_Descriptor_0, (uint32_t *) SOURCE_DATA);
    Cy_DMA_Descriptor_SetDstAddress(&TxDma2D_Descriptor_0, (uint32_t *) &UART_HW->TX_FIFO_WR);

    /* Set descriptor for PDMA channel */
    Cy_DMA_Channel_SetDescriptor(TxDma2D_HW, TxDma2D_CHANNEL, &TxDma2D_Descriptor_0);

    /* Initialize and enable interrupt from PDMA */
    Cy_SysInt_Init(&TX_DMA_2D_INT_CFG, &handle_PDMA_Interrupt);
    NVIC_EnableIRQ((IRQn_Type) NvicMux4_IRQn);

    /* Enable PDMA interrupt source. */
    Cy_DMA_Channel_SetInterruptMask(TxDma2D_HW, TxDma2D_CHANNEL, CY_DMA_INTR_MASK);

    /* Enable channel and PDMA block to start descriptor execution process */
    Cy_DMA_Channel_Enable(TxDma2D_HW, TxDma2D_CHANNEL);
    Cy_DMA_Enable(TxDma2D_HW);

    for (;;)
    {
        /* Check if SW1 is pressed */
        if (g_isInterrupt_SW1 == true)
        {
            /* Clear the flag */
            g_isInterrupt_SW1 = false;

            /* Trigger P-DMA Transfer */
            Cy_TrigMux_SwTrigger(TRIG_OUT_MUX_0_PDMA0_TR_IN0, CY_TRIGGER_TWO_CYCLES);
        }
    }
}

/* [] END OF FILE */
